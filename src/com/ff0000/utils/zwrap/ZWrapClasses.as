package com.ff0000.utils.zwrap {		import flash.utils.getQualifiedClassName;		dynamic public class ZWrapClasses {						/* -- ADD CLASS -------------------------------------------------		 *		 *  $_source			Class		The class to be wrapped		 *		 */		public function addClass( $_source:Class ):void {			var _className:String = getQualifiedClassName( $_source ).split( '::' )[1];			this[_className] = $_source;		}								/* -- MAKE CLASS ------------------------------------------------		 *		 *	$_classname			String		The previously added classname to instantiate		 *	$_propertyName		String		Specifies the zwrapper.property in which to save your instantiated class 		 *									OR, if no propertyName, zwrapper will return a singleton reference to requested class		 *	$_args				Array		Arguments to be included in class instantiation		 *		 */		public function make( $_className:String, $_propertyName:String=null, $_args:Array=null ):Class {			if( this[$_className] != null ) {				var ClassReference:Class = this[$_className];				if( $_propertyName ) {					if( $_args ) {						switch( $_args.length ) {							case 1 : this[$_propertyName] = new ClassReference( $_args[0] ); break;							case 2 : this[$_propertyName] = new ClassReference( $_args[0], $_args[1] ); break;							case 3 : this[$_propertyName] = new ClassReference( $_args[0], $_args[1], $_args[2] ); break;							case 4 : this[$_propertyName] = new ClassReference( $_args[0], $_args[1], $_args[2], $_args[3] ); break;							case 5 : this[$_propertyName] = new ClassReference( $_args[0], $_args[1], $_args[2], $_args[3], $_args[4] ); break;						}					}					else {						this[$_propertyName] = new ClassReference();					}					return null;				}				else {					return ClassReference;				}			}			else {				trace( $_className + ' not found!' );				return null;			}		}						// constructor		public function ZWrapClasses():void {			//		}	}}